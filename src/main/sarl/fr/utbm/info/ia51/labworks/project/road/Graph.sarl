package fr.utbm.info.ia51.labworks.project.road

import java.util.UUID
import java.util.List
import java.util.ArrayList
import java.util.Random
import io.sarl.lang.core.AgentContext

class Graph {
	var minEntryNode : int = 2
	var maxEntryNode : int = 5
	var minOtherNodes : int = 10
	var maxOtherNodes : int = 20
	var minNodeLinks : int = 3
	var maxNodeLinks : int = 5

	var context : AgentContext
	var generator : Random = new Random()
	var entryPoints : List<EntryPoint> = new ArrayList<EntryPoint>()
	var intersections : List<Intersection> = new ArrayList<Intersection>()

	new (context : AgentContext) {
		this.context = context
	}

	def enter(car : UUID) {
		var destination : Intersection = this.intersections.get(this.generator.nextInt(this.intersections.size()))
		this.entryPoints.get(this.generator.nextInt(this.entryPoints.size())).enter(car, destination)
	}
	
	def generateRandom() {
		var index : List<Integer> = new ArrayList<Integer>()
		var edges : List<List<Integer>> = new ArrayList<List<Integer>>()
		/* Initialize entry nodes */
		for (i : 0 ..< this.generator.nextInt(this.maxEntryNode - this.minEntryNode) + this.minEntryNode) {
			index.add(1)
			edges.add(new ArrayList<Integer>())	
		}
		/* Initialize random link number for each intersection */
		for (i : 0 ..< this.generator.nextInt(this.maxOtherNodes - this.minOtherNodes) + this.minOtherNodes) {
			index.add(minNodeLinks)
			edges.add(new ArrayList<Integer>())	
		}
		System.out.println("Initial intersection links number  : " + index.toString())
		
		/* Link each intersection, ensuring that each link is applied to both intersection */
		for (i : 0 ..< index.size()) {
			while (edges.get(i).size() < index.get(i)) {
				var newEdge : int
				do {
					newEdge = this.generator.nextInt(index.size())
				} while (
					newEdge == i || edges.get(i).contains(newEdge) || 
					index.get(newEdge) == 1 || edges.get(newEdge).size() >= this.maxNodeLinks
				)
				edges.get(i).add(newEdge)
			}
			
			for (j : 0 ..< index.size()) {
				if (j != i) {
					if (edges.get(j).contains(i) && !edges.get(i).contains(j)) {
						edges.get(i).add(j)
					}
					if (edges.get(i).contains(j) && !edges.get(j).contains(i)) {
						edges.get(j).add(i)
					}
				}	
			}
		}
		/* Update links number as it can grow if some links needed to force the bound to an intersection */
		for (i : 0 ..< index.size()) {
			index.set(i, edges.get(i).size())	
			edges.get(i).sortInplace()
		}
		/* Debugging */
		System.out.println("Resolved intersection links number : " + index.toString())
		System.out.println("Intersection links : " + edges.toString())
		
		/* Instantiate the roads, again ensuring that the same road object is used both ways */
		var roads : List<List<Road>> = new ArrayList<List<Road>>(index.size())
		for (i : 0 ..< index.size()) {
			roads.add(new ArrayList<Road>())
			for (e : edges.get(i)) {
				if (e > i) {
					var roadLength = 20.0 + generator.nextDouble * 100.0
					switch (generator.nextInt(2)) {
						case 0: {
							roads.get(i).add(new OneWayRoad(this.context, roadLength))
						}
						case 1: {
							roads.get(i).add(new TwoWayRoad(this.context, roadLength))
						}
					}
				} else {
					var existingRoadIndexInOtherIntersection : int = edges.get(e).indexOf(i)
					roads.get(i).add(roads.get(e).get(existingRoadIndexInOtherIntersection))
				}
			}
		}
		/* Instantiate intersections depending on the number of links
		 * Corresponding road links are given to the newly created object
		 * The intersections will tell the roads who they're linked to
		 * */
		this.intersections = new ArrayList<Intersection>()
		for (i : 0 ..< index.size()) {
			var nbLinks : Integer = index.get(i)
			if (nbLinks == 1) {
				this.entryPoints.add(new EntryPoint(this.context, roads.get(i)))
			} else if (nbLinks == 3) {
				switch (generator.nextInt(2)) {
					case 0: {
						intersections.add(new IntersectionT(this.context, roads.get(i)))
					}
					case 1: {
						intersections.add(new IntersectionY(this.context, roads.get(i)))
					}
				}
			} else if (nbLinks == 4) {
				switch (generator.nextInt(2)) {
					case 0: {
						intersections.add(new CrossIntersection(this.context, roads.get(i)))
					}
					case 1: {
						intersections.add(new Roundabout(this.context, roads.get(i)))
					}
				}
			} else {
				intersections.add(new Roundabout(this.context, roads.get(i)))
			}
		}
		
		/* Debugging */
		for (i : 0 ..< this.entryPoints.size()) {
			System.out.println("Entry point " + i + " : " + this.entryPoints.get(i))
		}
		for (i : 0 ..< intersections.size()) {
			System.out.println("Intersection " + (i + this.entryPoints.size()) + " : " + intersections.get(i))
		}
	}
}