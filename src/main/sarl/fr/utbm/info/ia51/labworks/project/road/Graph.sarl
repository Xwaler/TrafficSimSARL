package fr.utbm.info.ia51.labworks.project.road

import java.util.UUID
import java.util.List
import java.util.ArrayList
import java.util.Random
import io.sarl.lang.core.AgentContext

class Graph {
	var minEntryNode : int = 1
	var maxEntryNode : int = 3
	var minOtherNodes : int = 10
	var maxOtherNodes : int = 15
	var minNodeLinks : int = 3
	var maxNodeLinks : int = 5

	var context : AgentContext
	var generator : Random = new Random()
	var entryPoints : List<EntryPoint> = new ArrayList<EntryPoint>()
	var intersections : List<Intersection> = new ArrayList<Intersection>()

	new (context : AgentContext) {
		this.context = context
	}

	def enter(car : UUID) {
		var destination : Intersection = this.intersections.get(this.generator.nextInt(this.intersections.size()))
		this.entryPoints.get(this.generator.nextInt(this.entryPoints.size())).enter(car, destination)
	}
	
	def getNewObjectiveDifferentFrom(node : Intersection) {
		var destination : Intersection
		do {
			destination = this.intersections.get(this.generator.nextInt(this.intersections.size()))
		} while (destination == node)
		return destination
	}

	def getEntryPoints() : List<EntryPoint> {
		return this.entryPoints
	}

	def getIntersections() : List<Intersection> {
		return this.intersections
	}
	
	def generateRandom() {
		var index : List<Integer> = new ArrayList<Integer>()
		var edges : List<List<Integer>> = new ArrayList<List<Integer>>()
		/* Initialize entry nodes */
		for (i : 0 ..< this.generator.nextInt(this.maxEntryNode - this.minEntryNode) + this.minEntryNode) {
			index.add(1)
			edges.add(new ArrayList<Integer>())	
		}
		/* Initialize random link number for each intersection */
		for (i : 0 ..< this.generator.nextInt(this.maxOtherNodes - this.minOtherNodes) + this.minOtherNodes) {
			index.add(minNodeLinks)
			edges.add(new ArrayList<Integer>())	
		}
		System.out.println("Initial intersection links number  : " + index.toString())
		
		/* Link each intersection, ensuring that each link is applied to both intersection */
		for (i : 0 ..< index.size()) {
			while (edges.get(i).size() < index.get(i)) {
				var newEdge : int
				do {
					newEdge = this.generator.nextInt(index.size())
				} while (
					newEdge == i || edges.get(i).contains(newEdge) || 
					index.get(newEdge) == 1 || edges.get(newEdge).size() >= this.maxNodeLinks
				)
				edges.get(i).add(newEdge)
			}
			
			for (j : 0 ..< index.size()) {
				if (j != i) {
					if (edges.get(j).contains(i) && !edges.get(i).contains(j)) {
						edges.get(i).add(j)
					}
					if (edges.get(i).contains(j) && !edges.get(j).contains(i)) {
						edges.get(j).add(i)
					}
				}	
			}
		}
		/* Update links number as it can grow if some links needed to force the bound to an intersection */
		for (i : 0 ..< index.size()) {
			index.set(i, edges.get(i).size())	
			edges.get(i).sortInplace()
		}
		/* Debugging */
		System.out.println("Resolved intersection links number : " + index.toString())
		System.out.println("Intersection links : " + edges.toString())
		
		/* Instantiate the roads, again ensuring that the same road object is used both ways */
		var roads : List<List<Road>> = new ArrayList<List<Road>>(index.size())
		for (i : 0 ..< index.size()) {
			roads.add(new ArrayList<Road>())
			
			if (edges.get(i).size() == 1) {
				roads.get(i).add(new OneWayRoad(this.context))
			} else {
				for (e : edges.get(i)) {
					if (e > i) {
						switch (generator.nextInt(2)) {
							case 0: {
								roads.get(i).add(new TwoWayRoad(this.context))
							}
							case 1: {
								roads.get(i).add(new TwoWayRoad(this.context))
							}
						}
					} else {
						var existingRoadIndexInOtherIntersection : int = edges.get(e).indexOf(i)
						roads.get(i).add(roads.get(e).get(existingRoadIndexInOtherIntersection))
					}
				}
			}
		}
		/* Instantiate intersections depending on the number of links
		 * Corresponding road links are given to the newly created object
		 * The intersections will tell the roads who they're linked to
		 * */
		this.intersections = new ArrayList<Intersection>()
		for (i : 0 ..< index.size()) {
			var nbLinks : Integer = index.get(i)
			
			if (nbLinks == 1) {
				var x : double = generator.nextDouble * 0.1 + 0.1
				var y : double = generator.nextDouble * 0.8 + 0.1
				
				this.entryPoints.add(new EntryPoint(this.context, roads.get(i), x, y))
			}
			else {
				var x : double = generator.nextDouble * 0.7 + 0.2
				var y : double = generator.nextDouble * 0.8 + 0.1
				
				if (nbLinks == 3) {
					switch (generator.nextInt(2)) {
						case 0: {
							intersections.add(new IntersectionT(this.context, roads.get(i), x, y))
						}
						case 1: {
							intersections.add(new IntersectionY(this.context, roads.get(i), x, y))
						}
					}
				} else if (nbLinks == 4) {
					switch (generator.nextInt(2)) {
						case 0: {
							intersections.add(new CrossIntersection(this.context, roads.get(i), x, y))
						}
						case 1: {
							intersections.add(new Roundabout(this.context, roads.get(i), x, y))
						}
					}
				} else {
					intersections.add(new Roundabout(this.context, roads.get(i), x, y))
				}	
			}
		}
		
		for (entryPoint: this.entryPoints) {
			entryPoint.setLength(0.03)
		}
		for (intersection: this.intersections) {
			intersection.setLength(0.03)
			for (road : intersection.getLinks()) {
				if (road.getLength() == -1) {
					road.setLength(
						Math.sqrt(
							Math.pow(road.getPrimaryNode()
							.x - road.getSecondaryNode().x, 2) +
							Math.pow(road.getPrimaryNode().y - road.getSecondaryNode().y, 2)
						)
					)
				}
			}
		}
		
		/* Debugging */
		for (i : 0 ..< this.entryPoints.size()) {
			System.out.println("Entry point " + i + " : " + this.entryPoints.get(i))
		}
		for (i : 0 ..< intersections.size()) {
			System.out.println("Intersection " + (i + this.entryPoints.size()) + " : " + intersections.get(i))
		}
	}
	
	def clearCars() : void {
		for (entryPoint: this.entryPoints) {
			entryPoint.getCars().clear()
		}
		for (intersection: this.intersections) {
			intersection.getCars().clear()
			for (link: intersection.getLinks()) {
				link.getCars().clear()
			}
		}
	}
}