package fr.utbm.info.ia51.labworks.project.ui

import javax.swing.JPanel
import java.awt.Dimension
import java.awt.Color
import javax.swing.BoxLayout
import java.awt.Graphics
import fr.utbm.info.ia51.labworks.project.road.Graph
import java.util.Map
import java.util.UUID
import fr.utbm.info.ia51.labworks.project.road.Road
import fr.utbm.info.ia51.labworks.project.road.Intersection
import fr.utbm.info.ia51.labworks.project.events.CarProperties
import fr.utbm.info.ia51.labworks.project.road.OneWayRoad
import java.awt.Graphics2D
import java.awt.BasicStroke
import java.awt.RenderingHints
import java.util.Set
import org.arakhne.afc.references.WeakHashSet
import java.awt.Stroke
import fr.utbm.info.ia51.labworks.project.road.TwoWayRoad

class SimView extends JPanel {
	val dimension : Dimension
	var graph : Graph
	var carsProperties : Map<UUID, CarProperties>

	var laneWidth : int = 6
	var carDiameter : int = 5

	var rh : RenderingHints
	var defaultStroke : Stroke
	var dashedStroke : Stroke

	new (dimension : Dimension) {
		this.dimension = dimension
		this.layout = new BoxLayout(this, BoxLayout::X_AXIS)
		this.setPreferredSize(dimension)
		this.setBackground(Color.gray)

		this.rh = new RenderingHints(
			RenderingHints.KEY_ANTIALIASING,
			RenderingHints.VALUE_ANTIALIAS_ON
		)
		this.dashedStroke = new BasicStroke(1, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 0, #[9, 3], 0);
	}
	
	def setGraph(graph : Graph) : void {
		this.carsProperties = null
		this.graph = graph
		this.repaint()
	}
	
	def setCarsProperties(carsProperties : Map<UUID, CarProperties>) {
		this.carsProperties = carsProperties
		this.repaint()
	}
	
	def getRoadBetween(from : Intersection, to : Intersection) : Road {
		for (link : from.getLinks()) {
			if (
				(link.getPrimaryNode() === from && link.getSecondaryNode() === to) || 
				(link.getPrimaryNode() === to && link.getSecondaryNode() === from)
			) {
				return link
			}
		}
	}
	
	def drawOneWayRoad(g : Graphics2D, primary : Intersection, secondary : Intersection) : void {
		assert getRoadBetween(primary, secondary) instanceof OneWayRoad
		var road : OneWayRoad = getRoadBetween(primary, secondary) as OneWayRoad
		g.setColor(Color.white)
		
		var angle : double = Math.atan2(secondary.y - primary.y, secondary.x - primary.x)
		var cos : double = Math.cos(angle + Math.PI / 2)
		var sin : double = Math.sin(angle + Math.PI / 2)
		
		for (var i : double = -road.nbOfLane / 2.0; i <= road.nbOfLane / 2.0; i += 1.0) {
			if (i == -road.nbOfLane / 2.0 || i == road.nbOfLane / 2.0) {
				g.setStroke(this.defaultStroke)
			} else {
				g.setStroke(this.dashedStroke)
			}
			g.drawLine(
				(primary.x * this.dimension.width + i * cos * this.laneWidth) as int,
				(primary.y * this.dimension.height + i * sin * this.laneWidth) as int,
				(secondary.x * this.dimension.width + i * cos * this.laneWidth) as int,
				(secondary.y * this.dimension.height + i * sin * this.laneWidth) as int
			)
		}

		g.setColor(Color.red)
		if (this.carsProperties !== null) {
			for (car : road.getCars()) {
				var carProperties : CarProperties = this.carsProperties.get(car)
				var from : Intersection = carProperties.direction == 0 ? secondary : primary
				var to : Intersection = carProperties.direction == 0 ? primary : secondary
				var cosC : double = (1 + carProperties.lane) * (carProperties.direction == 0 ? -cos : cos)
				var sinC : double = (1 + carProperties.lane) * (carProperties.direction == 0 ? -sin : sin)
				g.fillOval(
					((carProperties.position * to.x + (1 - carProperties.position) * from.x) *
						this.dimension.width + cosC * this.laneWidth / 2 - this.carDiameter / 2
					) as int,
					((carProperties.position * to.y + (1 - carProperties.position) * from.y) *
						this.dimension.height + sinC * this.laneWidth / 2 - this.carDiameter / 2
					) as int,
					this.carDiameter,
					this.carDiameter
				)
			}
		}
	}
	
	def drawTwoWayRoad(g : Graphics2D, primary : Intersection, secondary : Intersection) : void {
		assert getRoadBetween(primary, secondary) instanceof TwoWayRoad
		var road : TwoWayRoad = getRoadBetween(primary, secondary) as TwoWayRoad
		g.setColor(Color.white)
		
		var angle : double = Math.atan2(secondary.y - primary.y, secondary.x - primary.x)
		var cos : double = Math.cos(angle + Math.PI / 2)
		var sin : double = Math.sin(angle + Math.PI / 2)

		for (var i : double = -road.nbOfLanePrimary; i <= road.nbOfLaneSecondary; i += 1.0) {
			if (i == -road.nbOfLanePrimary || i == 0 || i == road.nbOfLaneSecondary) {
				g.setStroke(this.defaultStroke)
			} else {
				g.setStroke(this.dashedStroke)
			}
			g.drawLine(
				(primary.x * this.dimension.width + i * cos * this.laneWidth) as int,
				(primary.y * this.dimension.height + i * sin * this.laneWidth) as int,
				(secondary.x * this.dimension.width + i * cos * this.laneWidth) as int,
				(secondary.y * this.dimension.height + i * sin * this.laneWidth) as int
			)
		}

		g.setColor(Color.red)
		if (this.carsProperties !== null) {
			for (car : road.getCars()) {
				var carProperties : CarProperties = this.carsProperties.get(car)
				var from : Intersection = carProperties.direction == 0 ? secondary : primary
				var to : Intersection = carProperties.direction == 0 ? primary : secondary
				var cosC : double = (1 + carProperties.lane) * (carProperties.direction == 0 ? -cos : cos)
				var sinC : double = (1 + carProperties.lane) * (carProperties.direction == 0 ? -sin : sin)
				g.fillOval(
					((carProperties.position * to.x + (1 - carProperties.position) * from.x) *
						this.dimension.width + cosC * this.laneWidth / 2 - this.carDiameter / 2
					) as int,
					((carProperties.position * to.y + (1 - carProperties.position) * from.y) *
						this.dimension.height + sinC * this.laneWidth / 2 - this.carDiameter / 2
					) as int,
					this.carDiameter,
					this.carDiameter
				)
			}
		}
	}

	def paintComponent(graphics : Graphics) {
        super.paintComponent(graphics)
		var g : Graphics2D = graphics as Graphics2D
		g.setRenderingHints(this.rh)
		this.defaultStroke = g.getStroke();

		g.setColor(Color.black)
		for (entryPoint : this.graph.getEntryPoints()) {
			g.fillRect(
				((entryPoint.x - entryPoint.getLength() / 2) * this.dimension.width) as int,
				((entryPoint.y - entryPoint.getLength() / 2) * this.dimension.height) as int,
				(entryPoint.getLength() * this.dimension.width) as int,
				(entryPoint.getLength() * this.dimension.height) as int
			)
		}
        for (intersection : this.graph.getIntersections()) {
			g.fillRect(
				((intersection.x - intersection.getLength() / 2) * this.dimension.width) as int,
				((intersection.y - intersection.getLength() / 2) * this.dimension.height) as int,
				(intersection.getLength() * this.dimension.width) as int,
				(intersection.getLength() * this.dimension.height) as int
			)
        }
		g.setStroke(new BasicStroke(2))
		var renderedRoads : Set<Road> = new WeakHashSet<Road>()
		for (intersection : this.graph.getIntersections()) {
			for (road : intersection.getLinks()) {
				if (renderedRoads.contains(road)) continue
				if (road instanceof OneWayRoad) {
					this.drawOneWayRoad(g, road.getPrimaryNode(), road.getSecondaryNode())
				} else {
					this.drawTwoWayRoad(g, road.getPrimaryNode(), road.getSecondaryNode())
				}
				renderedRoads.add(road)
			}
		}
	}
}
