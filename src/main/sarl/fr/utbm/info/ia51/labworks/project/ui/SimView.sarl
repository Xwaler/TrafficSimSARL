package fr.utbm.info.ia51.labworks.project.ui

import javax.swing.JPanel
import java.awt.Dimension
import java.awt.Color
import javax.swing.BoxLayout
import java.awt.Graphics
import fr.utbm.info.ia51.labworks.project.road.Graph
import java.util.Map
import java.util.UUID
import fr.utbm.info.ia51.labworks.project.road.Road
import fr.utbm.info.ia51.labworks.project.road.Intersection
import fr.utbm.info.ia51.labworks.project.events.CarProperties
import fr.utbm.info.ia51.labworks.project.road.OneWayRoad
import java.awt.Graphics2D
import java.awt.BasicStroke
import java.awt.RenderingHints
import java.util.Set
import org.arakhne.afc.references.WeakHashSet

class SimView extends JPanel {
	val dimension : Dimension
	var graph : Graph
	var carsProperties : Map<UUID, CarProperties>

	var laneWidth : int = 10
	var carDiameter : int = 8

	new (dimension : Dimension) {
		this.dimension = dimension
		this.layout = new BoxLayout(this, BoxLayout::X_AXIS)
		this.setPreferredSize(dimension)
		this.setBackground(Color.gray)
	}
	
	def setGraph(graph : Graph) : void {
		this.carsProperties = null
		this.graph = graph
		this.repaint()
	}
	
	def setCarsProperties(carsProperties : Map<UUID, CarProperties>) {
		this.carsProperties = carsProperties
		this.repaint()
	}
	
	def getRoadBetween(from : Intersection, to : Intersection) : Road {
		for (link : from.getLinks()) {
			if (
				(link.getPrimaryNode() === from && link.getSecondaryNode() === to) || 
				(link.getPrimaryNode() === to && link.getSecondaryNode() === from)
			) {
				return link
			}
		}
	}
	
	def drawOneWayRoad(g : Graphics, primary : Intersection, secondary : Intersection) : void {
		g.setColor(Color.white)
		var angle : double = Math.atan2(secondary.y - primary.y, secondary.x - primary.x)
		var cosP : double = Math.cos(angle + Math.PI / 2)
		var sinP : double = Math.sin(angle + Math.PI / 2)
		g.drawLine(
			(primary.x * this.dimension.width + cosP * this.laneWidth / 2) as int,
			(primary.y * this.dimension.height + sinP * this.laneWidth / 2) as int,
			(secondary.x * this.dimension.width + cosP * this.laneWidth / 2) as int,
			(secondary.y * this.dimension.height + sinP * this.laneWidth / 2) as int
		)
		var cosN : double = Math.cos(angle - Math.PI / 2)
		var sinN : double = Math.sin(angle - Math.PI / 2)
		g.drawLine(
			(primary.x * this.dimension.width + cosN * this.laneWidth / 2) as int,
			(primary.y * this.dimension.height + sinN * this.laneWidth / 2) as int,
			(secondary.x * this.dimension.width + cosN * this.laneWidth / 2) as int,
			(secondary.y * this.dimension.height + sinN * this.laneWidth / 2) as int
		)

		/* DEBUGGING DISPLAY */
		var road : Road = getRoadBetween(primary, secondary)
		g.setColor(Color.green)
		g.drawString(
			road.class.simpleName + "@" + road.hashCode,
			((0.5 * primary.x + 0.5 * secondary.x) * this.dimension.width - laneWidth) as int,
			((0.5 * primary.y + 0.5 * secondary.y) * this.dimension.height - laneWidth) as int
		)

		g.setColor(Color.red)
		if (this.carsProperties !== null) {
			for (car : getRoadBetween(primary, secondary).getCars()) {
				var carProperties : CarProperties = this.carsProperties.get(car)
				var from : Intersection = carProperties.direction == 0 ? secondary : primary
				var to : Intersection = carProperties.direction == 0 ? primary : secondary
				g.fillOval(
					((carProperties.position * to.x + (1 - carProperties.position) * from.x) *
						this.dimension.width - this.carDiameter / 2
					) as int,
					((carProperties.position * to.y + (1 - carProperties.position) * from.y) *
						this.dimension.height - this.carDiameter / 2
					) as int,
					this.carDiameter,
					this.carDiameter
				)
			}
		}
	}
	
	def drawTwoWayRoad(g : Graphics, primary : Intersection, secondary : Intersection) : void {
		g.setColor(Color.white)
		var angle : double = Math.atan2(secondary.y - primary.y, secondary.x - primary.x)
		g.drawLine(
			(primary.x * this.dimension.width) as int,
			(primary.y * this.dimension.height) as int,
			(secondary.x * this.dimension.width) as int,
			(secondary.y * this.dimension.height) as int
		)
		var cosP : double = Math.cos(angle + Math.PI / 2)
		var sinP : double = Math.sin(angle + Math.PI / 2)
		g.drawLine(
			(primary.x * this.dimension.width + cosP * this.laneWidth) as int,
			(primary.y * this.dimension.height + sinP * this.laneWidth) as int,
			(secondary.x * this.dimension.width + cosP * this.laneWidth) as int,
			(secondary.y * this.dimension.height + sinP * this.laneWidth) as int
		)
		var cosN : double = Math.cos(angle - Math.PI / 2)
		var sinN : double = Math.sin(angle - Math.PI / 2)
		g.drawLine(
			(primary.x * this.dimension.width + cosN * this.laneWidth) as int,
			(primary.y * this.dimension.height + sinN * this.laneWidth) as int,
			(secondary.x * this.dimension.width + cosN * this.laneWidth) as int,
			(secondary.y * this.dimension.height + sinN * this.laneWidth) as int
		)

		/* DEBUGGING DISPLAY */
		var road : Road = getRoadBetween(primary, secondary)
		g.setColor(Color.green)
		g.drawString(
			road.class.simpleName + "@" + road.hashCode,
			((0.5 * primary.x + 0.5 * secondary.x) * this.dimension.width - laneWidth) as int,
			((0.5 * primary.y + 0.5 * secondary.y) * this.dimension.height - laneWidth) as int
		)

		g.setColor(Color.red)
		if (this.carsProperties !== null) {
			for (car : getRoadBetween(primary, secondary).getCars()) {
				var carProperties : CarProperties = this.carsProperties.get(car)
				var from : Intersection = carProperties.direction == 0 ? secondary : primary
				var to : Intersection = carProperties.direction == 0 ? primary : secondary
				var cosC : double = carProperties.direction == 0 ? cosN : cosP
				var sinC : double = carProperties.direction == 0 ? sinN : sinP
				g.fillOval(
					((carProperties.position * to.x + (1 - carProperties.position) * from.x) *
						this.dimension.width + cosC * this.laneWidth / 2 - this.carDiameter / 2
					) as int,
					((carProperties.position * to.y + (1 - carProperties.position) * from.y) *
						this.dimension.height + sinC * this.laneWidth / 2 - this.carDiameter / 2
					) as int,
					this.carDiameter,
					this.carDiameter
				)
			}
		}
	}

	def paintComponent(graphics : Graphics) {
        super.paintComponent(graphics)
		var g : Graphics2D = graphics as Graphics2D
		var rh : RenderingHints = new RenderingHints(
			RenderingHints.KEY_ANTIALIASING,
			RenderingHints.VALUE_ANTIALIAS_ON
		)
		g.setRenderingHints(rh)

		for (entryPoint : this.graph.getEntryPoints()) {
			g.setColor(Color.black)
			g.fillRect(
				((entryPoint.x - entryPoint.getLength() / 2) * this.dimension.width) as int,
				((entryPoint.y - entryPoint.getLength() / 2) * this.dimension.height) as int,
				(entryPoint.getLength() * this.dimension.width) as int,
				(entryPoint.getLength() * this.dimension.height) as int
			)
			/* DEBUGGING DISPLAY
			 */
			g.setColor(Color.green)
			g.drawString(
				entryPoint.class.simpleName + "@" + entryPoint.hashCode,
				((entryPoint.x - entryPoint.getLength()) * this.dimension.width) as int,
				((entryPoint.y - entryPoint.getLength()) * this.dimension.height) as int
			)
		}
        for (intersection : this.graph.getIntersections()) {
			g.setColor(Color.black)
			g.fillRect(
				((intersection.x - intersection.getLength() / 2) * this.dimension.width) as int,
				((intersection.y - intersection.getLength() / 2) * this.dimension.height) as int,
				(intersection.getLength() * this.dimension.width) as int,
				(intersection.getLength() * this.dimension.height) as int
			)
			/* DEBUGGING DISPLAY
			 */
			g.setColor(Color.green)
			g.drawString(
				intersection.class.simpleName + "@" + intersection.hashCode,
				((intersection.x - intersection.getLength()) * this.dimension.width) as int,
				((intersection.y - intersection.getLength()) * this.dimension.height) as int
			)
        }
		g.setStroke(new BasicStroke(2))
		var renderedRoads : Set<Road> = new WeakHashSet<Road>()
		for (intersection : this.graph.getIntersections()) {
			for (road : intersection.getLinks()) {
				if (renderedRoads.contains(road)) continue
				if (road instanceof OneWayRoad) {
					this.drawOneWayRoad(g, road.getPrimaryNode(), road.getSecondaryNode())
				} else {
					this.drawTwoWayRoad(g, road.getPrimaryNode(), road.getSecondaryNode())
				}
				renderedRoads.add(road)
			}
		}
	}
}
