package fr.utbm.info.ia51.labworks.project.environment

import io.sarl.core.Initialize
import io.sarl.core.AgentSpawned
import io.sarl.core.Logging
import io.sarl.core.Lifecycle
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Schedules
import io.sarl.core.AgentTask
import java.util.UUID
import java.util.ArrayList

import fr.utbm.info.ia51.labworks.project.ui.MainFrame
import fr.utbm.info.ia51.labworks.project.car.AutonomousCar
import fr.utbm.info.ia51.labworks.project.car.HumanCar
import fr.utbm.info.ia51.labworks.project.road.Graph
import fr.utbm.info.ia51.labworks.project.events.StartSimulationEvent
import fr.utbm.info.ia51.labworks.project.events.Intent
import fr.utbm.info.ia51.labworks.project.events.PhysicsUpdate
import fr.utbm.info.ia51.labworks.project.events.PerceptionUpdate
import fr.utbm.info.ia51.labworks.project.car.Car
import fr.utbm.info.ia51.labworks.project.events.StopSimulationEvent
import java.util.List
import fr.utbm.info.ia51.labworks.project.road.Road
import fr.utbm.info.ia51.labworks.project.road.Intersection
import java.util.WeakHashMap
import fr.utbm.info.ia51.labworks.project.road.RoadElement

agent Environment {
	uses Logging, DefaultContextInteractions, Lifecycle, Schedules
	
	var UI : MainFrame
	var mesureFlux : double
	var tauxAccident : double
	var tempsTrajet : double
	var roads : Graph

	var nbCars : int
	var nbInitializedCars : int = 0
	var cars : ArrayList<UUID> = new ArrayList<UUID>
	var intents : ArrayList<Intent> = new ArrayList<Intent>
	var physicsUpdates : List<PhysicsUpdate> = new ArrayList<PhysicsUpdate>
	
	on Initialize {
		synchronized (this) {
			this.UI = occurrence.parameters.get(0) as MainFrame
			this.roads = new Graph(defaultContext)
			roads.generateRandom()
		}
	}
	
	on StartSimulationEvent {
		info("SIMULATION STARTED")
		synchronized (this) {
			this.nbInitializedCars = 0
			this.nbCars = occurrence.nbCars
			this.addCars(
				occurrence.nbCars,
				occurrence.autonomousProportions,
				occurrence.obedienceRate,
				occurrence.reactionTime,
				occurrence.perceptionErrorRate,
				occurrence.viewDistance,
				occurrence.FOV
			);
		}
	}

	on StopSimulationEvent {
		synchronized (this) {
			this.cars.clear()
			this.intents.clear()
		}
	}
	
	on AgentSpawned {
		synchronized (this) {
			var agentID : UUID = occurrence.agentID
			if (cars.contains(agentID)) {
				this.roads.enter(agentID)
				this.nbInitializedCars++
				if (this.nbInitializedCars == this.nbCars) {
					computePerceptions()
				}
			}
		}
	}
	
	def addCars(
		nbCars : int, 
		autonomousProportions : double, 
		obedienceRate : double,
		reactionTime : double,
		perceptionErrorRate : double,
		viewDistance : double,
		FOV : double
	) : void {
		var nbAutonomous : int = (nbCars * autonomousProportions) as int
		for (i : 0 ..< nbAutonomous) {
			var UUID = UUID::randomUUID()
			this.cars.add(UUID)
			spawnInContextWithID(typeof(AutonomousCar), UUID, defaultContext, 
				reactionTime, perceptionErrorRate, viewDistance, FOV)
		}
		for (i : 0 ..< nbCars - nbAutonomous) {
			var UUID = UUID::randomUUID()
			this.cars.add(UUID)
			spawnInContextWithID(typeof(HumanCar), UUID, defaultContext, 
				reactionTime, perceptionErrorRate, viewDistance, FOV, obedienceRate)
		}
	}

	on Intent {
		synchronized (this) {
			this.intents.add(occurrence);
			if (this.intents.size() == this.nbCars) {
				info("All intents received")
				resolveConflicts()
				task("frame_delay").in(500) [ computePerceptions() ]
			}
		}
	}

	def resolveConflicts() : void {
		// TODO: resolve conflicts
		this.physicsUpdates.clear()
		for (i : 0 ..< this.nbCars) {
			var update : PhysicsUpdate = new PhysicsUpdate()
			var intent : Intent = this.intents.get(i)
			update.newAcceleration = intent.intendedAcceleration
			update.newSpeed = intent.currentSpeed + update.newAcceleration
			update.newPosition = intent.currentPosition + update.newSpeed
			update.newLane = intent.intendedLaneChange
			if (update.newPosition >= 1.0) {
				intent.currentElement.exit(this.cars.get(i))
				if (intent.currentElement instanceof Road) {
					update.newElement = intent.direction == 0 ? 
						(intent.currentElement as Road).getPrimaryNode() : 
						(intent.currentElement as Road).getSecondaryNode()
				} 
				else if (intent.currentElement instanceof Intersection) {
					update.newElement = (intent.currentElement as Intersection).getLinks().get(intent.direction)
				}
				update.newPosition = 0
				update.newElement.enter(this.cars.get(i))
			}
			this.physicsUpdates.add(update)
		}
		/* Send physics update to cars */
		info("Sending physics updates")
		for (i : 0 ..< this.nbCars) {
			var update : PhysicsUpdate = this.physicsUpdates.get(i)
			emit(update) [ it.UUID == this.cars.get(i) ]
		}
		//TODO move this
		this.intents.clear()
	}
	
	def recursiveAdd(
		positionDataMap : WeakHashMap<UUID, PhysicsUpdate>,
		intentMap : WeakHashMap<UUID, Intent>, maxViewDistance : double, observerIntent : Intent,
		observerPositionData : PhysicsUpdate, result : ArrayList<PhysicsUpdate>, distanceToObserver : double,
		previousElement : RoadElement, currentElement : RoadElement
	) : void {
		/* Check if the current element hasn't already been processed */
		if (currentElement != previousElement) {
			if (currentElement instanceof Intersection) {

				/* add all cars in the intersection */
				for (neighbour : currentElement.cars){
					/* if neighbour isn't observer */
					if(neighbour != observerPositionData.source.UUID){
						result.add(positionDataMap.get(neighbour));
					}
				}
				
				/* If the view distance is greater that the already processed distance */
				if (distanceToObserver + currentElement.length <= maxViewDistance) {
					/* Keep going through next roads */
					for (road : (currentElement as Intersection).links) {
						recursiveAdd(positionDataMap, intentMap, maxViewDistance, observerIntent, observerPositionData, result,
							distanceToObserver + currentElement.length, currentElement, road)
					}
				}
			} else {
				// TODO for the first element , length isn't the right metric
				var currentElementAsRoad : Road = (currentElement as Road);
				for (neighbour : currentElement.cars) {
					if (neighbour != observerPositionData.source.UUID) {
						var neighbourPositionData : PhysicsUpdate = positionDataMap.get(neighbour)
						var neighbourIntent : Intent = intentMap.get(neighbour)
						
						var distanceNeighbourObserver : double = distanceToObserver;
						/* If the car hasn't changed element last frame */
						if(neighbourPositionData.newElement == neighbourIntent.currentElement){
							/* If both car are going in the same direction (direction of the first is different than the origin of the last) */
							if (neighbourIntent.direction != currentElementAsRoad.nodes.indexOf(previousElement)) {
								distanceNeighbourObserver += neighbourPositionData.newPosition * currentElement.length
							} else {
								distanceNeighbourObserver +=  (1 - neighbourPositionData.newPosition) * currentElement.length
							}
						} else {
							/* If both car are going in the same direction (origin are the same) */
							if (currentElementAsRoad.nodes.indexOf(neighbourIntent.currentElement) ==
								currentElementAsRoad.nodes.indexOf(previousElement)) {
								distanceNeighbourObserver += neighbourPositionData.newPosition * currentElement.length
							} else {
								distanceNeighbourObserver += (1 - neighbourPositionData.newPosition) * currentElement.length
							}
						}
						if (distanceToObserver + distanceNeighbourObserver <= maxViewDistance){
							result.add(positionDataMap.get(neighbour));
						}
					}
				}
				

				if (distanceToObserver + currentElement.length <= maxViewDistance) {
					/* Keep going through next roads */
					for (intersection : currentElementAsRoad.nodes) {
						recursiveAdd(positionDataMap, intentMap, maxViewDistance, observerIntent, observerPositionData, result,
							distanceToObserver + currentElement.length, currentElement, intersection)
					}
				}
			}
		}
	}
	
	def computePerceptions() : void {
		//TODO store in map instead of arraylist so it doesn't need to be rebuild
		var physicsUpdateMap : WeakHashMap<UUID, PhysicsUpdate> = new WeakHashMap<UUID, PhysicsUpdate>
		for (physicsUpdate : physicsUpdates) {
			physicsUpdateMap.put(physicsUpdate.source.UUID, physicsUpdate);
		}

		var intentMap : WeakHashMap<UUID, Intent> = new WeakHashMap<UUID, Intent>
		for (intent : intents) {
			intentMap.put(intent.source.UUID, intent);
		}
		
		for (physicsUpdate : physicsUpdates) {
			var result : ArrayList<PhysicsUpdate> = new ArrayList<PhysicsUpdate>
			recursiveAdd(physicsUpdateMap, intentMap, Integer.parseInt(UI.settingsFrame.viewDistance.getText()) / 100.0,
				intentMap.get(physicsUpdate.source.UUID), physicsUpdate, result,
							0, null, physicsUpdate.newElement)

			emit(new PerceptionUpdate(
				result
			))[it.UUID == physicsUpdate.source.UUID]
		}
		

		// for each element in physic update

		info("Sending perception updates")
	}
}
