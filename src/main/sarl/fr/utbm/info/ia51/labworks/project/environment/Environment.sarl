package fr.utbm.info.ia51.labworks.project.environment

import io.sarl.core.Initialize
import io.sarl.core.AgentSpawned
import io.sarl.core.Logging
import io.sarl.core.Lifecycle
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Schedules
import java.util.UUID
import java.util.ArrayList

import fr.utbm.info.ia51.labworks.project.ui.MainFrame
import fr.utbm.info.ia51.labworks.project.car.AutonomousCar
import fr.utbm.info.ia51.labworks.project.car.HumanCar
import fr.utbm.info.ia51.labworks.project.road.Graph
import fr.utbm.info.ia51.labworks.project.events.StartSimulationEvent
import fr.utbm.info.ia51.labworks.project.events.Intent
import fr.utbm.info.ia51.labworks.project.events.PhysicsUpdate
import fr.utbm.info.ia51.labworks.project.events.PerceptionUpdate
import fr.utbm.info.ia51.labworks.project.car.Car
import fr.utbm.info.ia51.labworks.project.events.StopSimulationEvent
import java.util.List
import fr.utbm.info.ia51.labworks.project.road.Road
import fr.utbm.info.ia51.labworks.project.road.Intersection
import java.util.Map
import java.util.WeakHashMap
import io.sarl.core.AgentTask
import fr.utbm.info.ia51.labworks.project.events.CarProperties
import fr.utbm.info.ia51.labworks.project.events.GenerateRoadsEvent

agent Environment {
	uses Logging, DefaultContextInteractions, Lifecycle, Schedules
	
	var UI : MainFrame
	var mesureFlux : double
	var tauxAccident : double
	var tempsTrajet : double
	var roads : Graph
	var frameDelayTask : AgentTask

	var nbCars : int
	var nbInitializedCars : int = 0
	var cars : List<UUID> = new ArrayList<UUID>
	var intents : Map<UUID, Intent> = new WeakHashMap<UUID, Intent>
	var physicsUpdates : Map<UUID, PhysicsUpdate> = new WeakHashMap<UUID, PhysicsUpdate>
	var carsProperties : Map<UUID, CarProperties> = new WeakHashMap<UUID, CarProperties>
	
	on Initialize {
		synchronized (this) {
			this.UI = occurrence.parameters.get(0) as MainFrame
			this.roads = new Graph(defaultContext)
			this.roads.generateRandom()
			this.UI.passGraph(this.roads)
		}
	}
	
	on StartSimulationEvent {
		info("SIMULATION STARTED")
		synchronized (this) {
			this.frameDelayTask = task("frame_delay")
			this.nbInitializedCars = 0
			this.nbCars = occurrence.nbCars
			this.addCars(
				occurrence.nbCars,
				occurrence.autonomousProportions,
				occurrence.obedienceRate,
				occurrence.reactionTime,
				occurrence.perceptionErrorRate,
				occurrence.viewDistance,
				occurrence.FOV
			);
		}
	}

	on StopSimulationEvent {
		synchronized (this) {
			this.cars.clear()
			this.roads.clearCars()
			this.intents.clear()
			this.physicsUpdates.clear()
			frameDelayTask.cancel()
		}
	}
	
	on GenerateRoadsEvent {
		synchronized (this) {
			this.roads = new Graph(defaultContext)
			this.roads.generateRandom()
			this.UI.passGraph(this.roads)	
		}
	}
	
	on AgentSpawned {
		synchronized (this) {
			var agentID : UUID = occurrence.agentID
			if (this.cars.contains(agentID)) {
				this.roads.enter(agentID)
				this.nbInitializedCars++
				if (this.nbInitializedCars == this.nbCars) {
					computePerceptions()
				}
			}
		}
	}
	
	def addCars(
		nbCars : int, 
		autonomousProportions : double, 
		obedienceRate : double,
		reactionTime : double,
		perceptionErrorRate : double,
		viewDistance : double,
		FOV : double
	) : void {
		var nbAutonomous : int = (nbCars * autonomousProportions) as int
		for (i : 0 ..< nbAutonomous) {
			var UUID = UUID::randomUUID()
			this.cars.add(UUID)
			spawnInContextWithID(typeof(AutonomousCar), UUID, defaultContext, 
				reactionTime, perceptionErrorRate, viewDistance, FOV)
		}
		for (i : 0 ..< nbCars - nbAutonomous) {
			var UUID = UUID::randomUUID()
			this.cars.add(UUID)
			spawnInContextWithID(typeof(HumanCar), UUID, defaultContext, 
				reactionTime, perceptionErrorRate, viewDistance, FOV, obedienceRate)
		}
	}

	@SuppressWarnings("discouraged_occurrence_readonly_use")
	on Intent {
		synchronized (this) {
			if (this.cars.contains(occurrence.source.UUID)) {
				this.intents.put(occurrence.source.UUID, occurrence);
				if (this.intents.size() == this.nbCars) {
					resolveConflicts()
					frameDelayTask.in(1000 / 60)[computePerceptions()]
					this.UI.passCarProperties(this.carsProperties)
					this.UI.repaint()
				}	
			}
		}
	}

	def resolveConflicts() : void {
		// TODO: actually resolve conflicts
		this.physicsUpdates.clear()
		for (pair : this.intents.entrySet()) {
			var update : PhysicsUpdate = new PhysicsUpdate()
			var carUUID : UUID = pair.getKey()
			var intent : Intent = pair.getValue()
			update.newAcceleration = intent.intendedAcceleration
			update.newSpeed = intent.currentSpeed + update.newAcceleration
			update.newPosition = intent.currentPosition + (update.newSpeed / intent.currentElement.getLength())
			update.newLane = intent.intendedLaneChange
			if (update.newPosition >= 1.0) {
				intent.currentElement.exit(carUUID)
				if (intent.currentElement instanceof Road) {
					update.newElement = intent.direction == 0 ? 
						(intent.currentElement as Road).getPrimaryNode() : 
						(intent.currentElement as Road).getSecondaryNode()
				} 
				else if (intent.currentElement instanceof Intersection) {
					update.newElement = (intent.currentElement as Intersection).getLinks().get(intent.direction)
				}
				update.newPosition = 0
				update.newElement.enter(carUUID)
			}
			else {
				update.newElement = intent.currentElement
			}
			this.physicsUpdates.put(carUUID, update)
		}
		this.carsProperties.clear()
		for (car: this.cars) {
			this.carsProperties.put(car, new CarProperties(
				this.intents.get(car),
				this.physicsUpdates.get(car)
			))
		}
		/* Send physics update to cars */
		for (pair : this.physicsUpdates.entrySet()) {
			emit(pair.getValue())[ it.UUID == pair.getKey() ]
		}
	}
	
	def computePerceptions() : void {
		synchronized (this) {
			this.intents.clear()
			for (car : cars) {
				emit(new PerceptionUpdate(
					new ArrayList<Car>()
				)) [it.UUID == car]
			}	
		}
	}
}
