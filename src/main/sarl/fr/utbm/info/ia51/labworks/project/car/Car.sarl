package fr.utbm.info.ia51.labworks.project.car

import io.sarl.core.Logging
import io.sarl.lang.core.Behavior
import io.sarl.core.Behaviors
import io.sarl.core.Lifecycle
import io.sarl.core.Initialize
import io.sarl.core.DefaultContextInteractions

import fr.utbm.info.ia51.labworks.project.road.RoadElement
import fr.utbm.info.ia51.labworks.project.events.StopSimulationEvent
import fr.utbm.info.ia51.labworks.project.events.BehaviorInitialize
import fr.utbm.info.ia51.labworks.project.events.PhysicsUpdate
import fr.utbm.info.ia51.labworks.project.events.PerceptionUpdate
import fr.utbm.info.ia51.labworks.project.events.PropertiesUpdate
import fr.utbm.info.ia51.labworks.project.events.Intent
import java.util.Random
import fr.utbm.info.ia51.labworks.project.road.Road
import fr.utbm.info.ia51.labworks.project.road.Intersection
import java.util.HashMap
import fr.utbm.info.ia51.labworks.project.road.EntryPoint
import fr.utbm.info.ia51.labworks.project.road.Intersection
import fr.utbm.info.ia51.labworks.project.road.OneWayRoad
import fr.utbm.info.ia51.labworks.project.road.TwoWayRoad
>>>>>>> Stashed changes
import fr.utbm.info.ia51.labworks.project.road.TwoWayRoad

agent Car {
	uses Lifecycle, Logging, Behaviors, DefaultContextInteractions

	protected var startPoint : RoadElement
	protected var endPoint : RoadElement
	protected var currentElement : RoadElement
	protected var speed : double
	protected var acceleration : double
	protected var positionInRoad : double
	protected var lane : double
	protected var direction : int
	protected var obedienceRate : double
	protected var reactionTime : double
	protected var perceptionErrorRate : double
	protected var viewDistance : double
	protected var FOV : double
	protected var carBehavior : Behavior
	
	on Initialize {
		synchronized (this) {
			this.reactionTime = occurrence.parameters.get(0) as Double
			this.perceptionErrorRate = occurrence.parameters.get(1) as Double
			this.viewDistance = occurrence.parameters.get(2) as Double
			this.FOV = occurrence.parameters.get(3) as Double
		}
	}
	
	on StopSimulationEvent {
		synchronized (this) {
			if (this.carBehavior !== null) {
				unregisterBehavior(this.carBehavior);
			}
		}
		killMe
	}
	
	def registerNewBehavior(carBehavior : Behavior) : void {
		synchronized (this) {
			this.carBehavior = carBehavior
			registerBehavior(this.carBehavior);
			wake(new BehaviorInitialize)
		}
	}
	
	on PropertiesUpdate {
		synchronized (this) {
			this.reactionTime = occurrence.reactionTime
			this.perceptionErrorRate = occurrence.perceptionErrorRate
			this.viewDistance = occurrence.viewDistance
			this.FOV = occurrence.FOV	
		}
	}
	
	@SuppressWarnings("discouraged_occurrence_readonly_use")
	on PhysicsUpdate {
		synchronized (this) {
			this.positionInRoad = occurrence.newPosition
			this.speed = occurrence.newSpeed
			this.acceleration = occurrence.newAcceleration
			this.lane = occurrence.newLane
			if (this.currentElement !== occurrence.newElement) {
				// TODO: the car changed road => need to change direction
				if (occurrence.newElement instanceof Road && this.currentElement instanceof Intersection) {
					if ((occurrence.newElement as Road).primaryNodeIs(this.currentElement as Intersection)) {
						this.direction = 1
					} else {
						this.direction = 0
					}
				} else if (occurrence.newElement instanceof Intersection) {
					this.direction = new Random().nextInt((occurrence.newElement as Intersection).getLinks().size())
				}
			}
			this.currentElement = occurrence.newElement
		}
	}
	
	on PerceptionUpdate {
		/* TODO: Process perception */
		synchronized (this) {
			if (this.currentElement === null) { // hasn't yet received the enter road event
				emit(occurrence) [ it.UUID == this.ID ] // delaying handling
			}
			else {
				/* TODO: Send intent with perception related values */
				emit(new Intent(
					this.speed < 0.005 && new Random().nextBoolean ? 0.0001 : 0,
					this.lane,
					this.positionInRoad,
					this.speed,
					this.currentElement,
					this.direction
				))
			}
		}
	}
	
	def pathFinding(){
		var visited = new HashMap<Intersection, Integer>
		var pathFind = false
		var tempNode : Intersection
		if (this.startPoint != null) {
			tempNode = (this.startPoint as EntryPoint)
			visited.put(tempNode, 0)
			while(!pathFind){
				for (road : tempNode.getLinks()) {
					if(road instanceof OneWayRoad){
						if ((road as OneWayRoad).entryAllowed(tempNode)) {
							info("Next node :"+road.getSecondaryNode())
						}
					}else if(road instanceof TwoWayRoad){
						//if((road as TwoWayRoad)){}
					}
				}
			}
		}else{
			info("error")
		}
	}

}
