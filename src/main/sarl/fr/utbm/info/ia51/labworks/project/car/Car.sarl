package fr.utbm.info.ia51.labworks.project.car

import io.sarl.core.Logging
import io.sarl.lang.core.Behavior
import io.sarl.core.Behaviors
import io.sarl.core.Lifecycle
import io.sarl.core.Initialize
import io.sarl.core.DefaultContextInteractions

import fr.utbm.info.ia51.labworks.project.road.RoadElement
import fr.utbm.info.ia51.labworks.project.events.StopSimulationEvent
import fr.utbm.info.ia51.labworks.project.events.BehaviorInitialize
import fr.utbm.info.ia51.labworks.project.events.PhysicsUpdate
import fr.utbm.info.ia51.labworks.project.events.PerceptionUpdate
import fr.utbm.info.ia51.labworks.project.events.PropertiesUpdate
import fr.utbm.info.ia51.labworks.project.events.Intent
import java.util.Random
import fr.utbm.info.ia51.labworks.project.road.Road
import fr.utbm.info.ia51.labworks.project.road.Intersection
import fr.utbm.info.ia51.labworks.project.road.OneWayRoad
import java.util.WeakHashMap
import java.util.ArrayList
import java.util.Map.Entry
import fr.utbm.info.ia51.labworks.project.events.EnterEntryPoint
import fr.utbm.info.ia51.labworks.project.road.TwoWayRoad
import java.util.Collections
import java.util.List

agent Car {
	uses Lifecycle, Logging, Behaviors, DefaultContextInteractions

	protected var startPoint : RoadElement
	protected var endPoint : RoadElement
	protected var currentElement : RoadElement
	protected var path : List<Intersection>
	protected var speed : double
	protected var acceleration : double
	protected var positionInRoad : double
	protected var lane : double
	protected var direction : int
	protected var obedienceRate : double
	protected var reactionTime : double
	protected var perceptionErrorRate : double
	protected var viewDistance : double
	protected var FOV : double
	protected var carBehavior : Behavior
	
	on Initialize {
		synchronized (this) {
			this.reactionTime = occurrence.parameters.get(0) as Double
			this.perceptionErrorRate = occurrence.parameters.get(1) as Double
			this.viewDistance = occurrence.parameters.get(2) as Double
			this.FOV = occurrence.parameters.get(3) as Double
		}
	}
	
	on EnterEntryPoint {
		synchronized (this) {
			if (this.currentElement === null) { // TODO: remove this once the cars are disallowed to return to an entrypoint
				this.currentElement = occurrence.road
				this.startPoint = occurrence.road
				this.endPoint = occurrence.destination
				this.direction = 0
				this.pathFinding()
				info("Path :" + this.path)
				emit(new Intent(
					0,
					this.lane,
					this.positionInRoad,
					this.speed,
					this.currentElement,
					this.direction
				))
			}
		}
	}
	
	on StopSimulationEvent {
		killMe
	}

	synchronized def registerNewBehavior(carBehavior : Behavior) : void {
		this.carBehavior = carBehavior
		registerBehavior(this.carBehavior);
		wake(new BehaviorInitialize)
	}
	
	on PropertiesUpdate {
		synchronized (this) {
			this.reactionTime = occurrence.reactionTime
			this.perceptionErrorRate = occurrence.perceptionErrorRate
			this.viewDistance = occurrence.viewDistance
			this.FOV = occurrence.FOV	
		}
	}
	
	@SuppressWarnings("discouraged_occurrence_readonly_use")
	on PhysicsUpdate {
		synchronized (this) {
			this.positionInRoad = occurrence.newPosition
			this.speed = occurrence.newSpeed
			this.acceleration = occurrence.newAcceleration
			this.lane = occurrence.newLane
			if (this.currentElement !== occurrence.newElement) {
				// TODO: the car changed road => need to change direction
				if (occurrence.newElement instanceof Road && this.currentElement instanceof Intersection) {
					if ((occurrence.newElement as Road).primaryNodeIs(this.currentElement as Intersection)) {
						this.direction = 1
					} else {
						this.direction = 0
					}
				} else if (occurrence.newElement instanceof Intersection) {
					this.direction = new Random().nextInt((occurrence.newElement as Intersection).getLinks().size())
				}
			}
			this.currentElement = occurrence.newElement
		}
	}
	
	on PerceptionUpdate {
		synchronized (this) {
			/* TODO: Process perception */
			/* TODO: Send intent with perception related values */
			emit(new Intent(
				this.speed < 0.005 && new Random().nextBoolean ? 0.0001 : 0,
				this.lane,
				this.positionInRoad,
				this.speed,
				this.currentElement,
				this.direction
			))
		}
	}
	
	synchronized def pathFinding(){
		var previouslyVisited : Road
		var visited = new WeakHashMap<Intersection,Double>
		var nodesToVisit = new WeakHashMap<Intersection, Double>
		var tempNodesToVisit : WeakHashMap<Intersection, Double>
		
		var tempNode = (this.startPoint as Intersection)
		var pathFound = false
		var pathGenerated = false
		
		nodesToVisit.put(this.startPoint as Intersection, 0.0)
		var nodesToVisitByLength : ArrayList<Entry<Intersection, Double>> = new ArrayList<Entry<Intersection, Double>>
		nodesToVisitByLength.sort(Entry.comparingByValue())
		
		if (tempNode !== null) {
			while (!pathFound){
				tempNodesToVisit = new WeakHashMap(nodesToVisit)
				nodesToVisitByLength = new ArrayList<Entry<Intersection, Double>>(tempNodesToVisit.entrySet())
				nodesToVisit.clear()
				for (node : nodesToVisitByLength) {
					if (!pathFound) {
						if (!visited.containsKey(node)) {
							for (road : node.getKey().getAccessibleLinks()) {
								if (road instanceof OneWayRoad) {
									if (road.getSecondaryNode() != this.endPoint) {
										if (nodesToVisit.containsKey(road.getSecondaryNode())) {
											if (nodesToVisit.get(road.getSecondaryNode()) > node.getValue() + road.getLength()) {
												nodesToVisit.
													put(road.getSecondaryNode(), node.getValue() + road.getLength())
											}
										} else {
											nodesToVisit.put(road.getSecondaryNode(), road.getLength()+ node.getValue())
										}
									} else {
										info("PathFound, start:" + this.startPoint + ", end:" + this.endPoint)
										pathFound = true;
										tempNode = node.getKey()
									}
								} else if (road instanceof TwoWayRoad && road != previouslyVisited) {
									var nextNode : Intersection = road.getOtherNode(node.getKey())
									if (nextNode != this.endPoint) {
										if (nodesToVisit.containsKey(nextNode)) {
											if (nodesToVisit.get(nextNode) > node.getValue() + road.getLength()) {
												nodesToVisit.put(nextNode, node.getValue() + road.getLength())
												previouslyVisited = road
											}
										} else {
											nodesToVisit.put(nextNode, node.getValue() + road.getLength())
											if (Collections.min(nodesToVisit.values()) > road.getLength()) {
												previouslyVisited = road
											}
										}
									} else {
										info("PathFound, start:" + this.startPoint + ", end:" + this.endPoint)
										pathFound = true;
										tempNode = node.getKey()
									}
								}
							}
						}
					}
					visited.put(node.getKey(), node.getValue())
				}
			}
			
			this.path = new ArrayList<Intersection>(2)
			path.add(this.endPoint as Intersection)
			path.add(tempNode)
			if (tempNode != this.startPoint) {
				while (!pathGenerated) {
					for (road : tempNode.getLinks()) {
						var nextNode : Intersection = road.getOtherNode(tempNode)
						if (road.entryAllowed(nextNode)) {
							if (nextNode != this.startPoint) {
								if (visited.containsKey(nextNode) && (visited.get(nextNode) + road.getLength()) == visited.get(tempNode)) {
									path.add(nextNode)
									tempNode = nextNode
								}
							} else {
								path.add(nextNode)
								pathGenerated = true
								break
							}
						}
					}
				}
			}
			path.reverse()
		}
	}
}
